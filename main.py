import asyncio
import os
import html
import re
import datetime
from io import BytesIO

from dotenv import load_dotenv

# Load environment variables before importing internal modules
load_dotenv()

import zbx
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.enums import ParseMode
from aiogram.types import InputFile
from aiogram.client.default import DefaultBotProperties
BOT_TOKEN = os.getenv("BOT_TOKEN")
# ADMIN_CHAT_IDS: comma-separated list of chat IDs
ADMIN_CHAT_IDS = [int(cid) for cid in os.getenv("ADMIN_CHAT_IDS", "").split(",") if cid.strip()]
ZABBIX_WEB = os.getenv("ZABBIX_WEB")  # e.g. https://zabbix.example.com

# Initialize Bot and Dispatcher
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

# Initialize FastAPI app
app = FastAPI()

# Aiogram command handlers
@dp.message(Command("status"))
async def cmd_status(msg: types.Message):
    params = {
        "output": ["eventid", "name", "severity", "clock"],
        "sortfield": "clock",
        "sortorder": "DESC",
    }
    # Try requesting hosts directly; older Zabbix versions don't support it
    problems = await zbx.call("problem.get", {**params, "selectHosts": ["name"]})
    if not problems:
        problems = await zbx.call("problem.get", params)
        event_ids = [p["eventid"] for p in problems]
        hosts_info = await zbx.call(
            "event.get",
            {"output": ["eventid"], "eventids": event_ids, "selectHosts": ["name"]},
        )
        host_map = {e["eventid"]: e.get("hosts", [{}])[0].get("name") for e in hosts_info}
    else:
        host_map = {
            p["eventid"]: p.get("hosts", [{}])[0].get("name") for p in problems
        }

    sev_map = {
        0: "–ù–µ –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–æ",
        1: "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
        2: "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ",
        3: "–°—Ä–µ–¥–Ω—è—è",
        4: "–í—ã—Å–æ–∫–∞—è",
        5: "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è",
    }

    counts = {name: 0 for name in sev_map.values()}
    details = []
    for pr in problems:
        sev_name = sev_map[int(pr["severity"])]
        counts[sev_name] += 1

        host = host_map.get(pr["eventid"], "?")
        clock = int(pr.get("clock", 0))
        ts = datetime.datetime.fromtimestamp(clock).strftime("%Y-%m-%d %H:%M")
        details.append(
            f"{sev_name} ‚Äî <b>{html.escape(host)}</b>: {html.escape(pr['name'])} ({ts})"
        )

    lines = [f"{k}: <b>{v}</b>" for k, v in counts.items() if v]

    text = "‚úÖ –ü—Ä–æ–±–ª–µ–º –Ω–µ—Ç" if not lines else "üñ• <b>–°–≤–æ–¥–∫–∞ –ø—Ä–æ–±–ª–µ–º</b>\n" + "\n".join(lines)
    if details:
        text += "\n\n<b>–¢–µ–∫—É—â–∏–µ –ø—Ä–æ–±–ª–µ–º—ã:</b>\n" + "\n".join(details[:15])

    await msg.answer(text)

@dp.message(Command("ping"))
async def cmd_ping(msg: types.Message, command: Command):
    if not command.args:
        return await msg.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /ping &lt;host&gt;")
    host = command.args.strip()
    proc = await asyncio.create_subprocess_exec(
        "ping", "-c", "4", host,
        stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
    )
    out, err = await proc.communicate()
    ok = proc.returncode == 0
    reply = f"{'‚úÖ' if ok else '‚ùå'} <b>{html.escape(host)}</b>\n<pre>{html.escape((out or err).decode())}</pre>"
    await msg.answer(reply)

@dp.message(Command("graph"))
async def cmd_graph(msg: types.Message, command: Command):
    parts = (command.args or "").split()
    if not parts:
        return await msg.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /graph <itemid> [–º–∏–Ω—É—Ç]")
    try:
        itemid = int(parts[0])
    except ValueError:
        return await msg.answer("‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π itemid</b>\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /graph <itemid> [–º–∏–Ω—É—Ç]")
    minutes = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else 60
    period = minutes * 60
    await msg.answer("‚è≥ –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∞‚Ä¶")
    try:
        png = await zbx.chart_png(itemid, period)
        bio = BytesIO(png)
        bio.name = f"item_{itemid}.png"
        await msg.answer_document(InputFile(bio))
    except Exception as e:
        await msg.answer(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –≥—Ä–∞—Ñ–∏–∫–∞: <pre>{html.escape(str(e))}</pre>")

@dp.message(Command("help"))
async def cmd_help(msg: types.Message):
    text = (
        "<b>üìñ –°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥ Phystech Zabbix Bot:</b>\n\n"
        "/status ‚Äî —Å–≤–æ–¥–∫–∞ –∏ —Å–ø–∏—Å–æ–∫ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø—Ä–æ–±–ª–µ–º\n"
        "/ping &lt;host&gt; ‚Äî –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ö–æ—Å—Ç–∞\n"
        "/graph &lt;itemid&gt; [–º–∏–Ω—É—Ç] ‚Äî –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫ –º–µ—Ç—Ä–∏–∫–∏\n"
        "/help ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É"
    )
    await msg.answer(text)

# FastAPI endpoints
@app.get("/healthz")
def health():
    return {"status": "ok"}

@app.post("/zabbix")
async def zabbix_alert(req: Request):
    """Receive alerts from Zabbix and forward them to Telegram."""
    payload = await req.json()

    # Remove links from the incoming message to avoid leaking internal URLs
    raw_message = str(payload.get("message", payload))
    clean_message = re.sub(r"<a[^>]*>.*?</a>", "", raw_message, flags=re.DOTALL)

    # Try to extract problem/event ID from a link like ?eventid=1234
    id_match = re.search(r"eventid=(\d+)", raw_message)
    if id_match:
        clean_message += f"\n–ù–æ–º–µ—Ä –ø—Ä–æ–±–ª–µ–º—ã: {id_match.group(1)}"

    text = (
        f"üì° <b>{html.escape(payload.get('subject', 'Zabbix alert'))}</b>\n"
        f"{html.escape(clean_message)}"
    )

    for chat_id in ADMIN_CHAT_IDS:
        await bot.send_message(chat_id, text)

    return JSONResponse({"ok": True})

# Startup and polling
async def on_startup():
    await bot.delete_webhook(drop_pending_updates=True)
    await bot.set_my_commands([
        types.BotCommand(command="status", description="–°–≤–æ–¥–∫–∞ –ø—Ä–æ–±–ª–µ–º"),
        types.BotCommand(command="ping",   description="–ü–∏–Ω–≥ —Ö–æ—Å—Ç–∞"),
        types.BotCommand(command="graph",  description="–ì—Ä–∞—Ñ–∏–∫ –º–µ—Ç—Ä–∏–∫–∏"),
        types.BotCommand(command="help",   description="–°–ø—Ä–∞–≤–∫–∞"),
    ])
    print("‚úÖ Webhook —É–¥–∞–ª—ë–Ω, –∫–æ–º–∞–Ω–¥—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã")

async def main():
    from uvicorn import Config, Server
    await on_startup()
    config = Config(app, host="0.0.0.0", port=8000, loop="asyncio")
    server = Server(config)
    await asyncio.gather(dp.start_polling(bot), server.serve())

if __name__ == "__main__":
    asyncio.run(main())
